<#
.SYNOPSIS
  Production-grade database setup and EF Core migration script.
  Eliminates 28P01 / SCRAM-SHA-256 authentication failures.
.DESCRIPTION
  1. Detects PostgreSQL container credentials
  2. Verifies TCP connectivity with password
  3. Exports deterministic connection string
  4. Applies EF Core migrations
  5. Runs zero-warning build
.EXAMPLE
  .\Setup-DbAndBuild.ps1
  .\Setup-DbAndBuild.ps1 -ContainerName mic-postgres -VerboseEf
#>
param(
    [string]$ContainerName = 'mic-postgres',
    [string]$SlnPath = 'MIC.sln',
    [switch]$VerboseEf,
    [switch]$SkipBuild
)

$ErrorActionPreference = 'Stop'

function Write-Step($m) { Write-Host "`n==> $m" -ForegroundColor Cyan }
function Write-Ok($m) { Write-Host "? $m" -ForegroundColor Green }
function Write-Warn($m) { Write-Host "! $m" -ForegroundColor Yellow }
function Write-Fail($m) { Write-Host "? $m" -ForegroundColor Red }

# ?????????????????????????????????????????????????????????????
# STEP 1: Verify Docker container is running
# ?????????????????????????????????????????????????????????????
Write-Step "Checking Docker container '$ContainerName'"

$containerStatus = docker inspect $ContainerName --format='{{.State.Running}}' 2>$null
if ($containerStatus -ne 'true') {
    Write-Fail "Container '$ContainerName' is not running"
    Write-Host "Run: docker-compose up -d" -ForegroundColor Yellow
    exit 1
}
Write-Ok "Container is running"

# ?????????????????????????????????????????????????????????????
# STEP 2: Extract credentials from container environment
# ?????????????????????????????????????????????????????????????
Write-Step "Extracting PostgreSQL credentials from container"

$envLines = docker inspect $ContainerName --format='{{range .Config.Env}}{{println .}}{{end}}'
$envMap = @{}
foreach ($line in $envLines) {
    if ($line -match '^([^=]+)=(.*)$') {
        $envMap[$Matches[1]] = $Matches[2]
    }
}

$pgUser = if ($envMap['POSTGRES_USER']) { $envMap['POSTGRES_USER'] } else { 'postgres' }
$pgPwd  = if ($envMap['POSTGRES_PASSWORD']) { $envMap['POSTGRES_PASSWORD'] } else { 'postgres' }
$pgDb   = if ($envMap['POSTGRES_DB']) { $envMap['POSTGRES_DB'] } else { $pgUser }
$pgHost = 'localhost'
$pgPort = '5432'

Write-Ok "Detected: User=$pgUser Database=$pgDb"

# ?????????????????????????????????????????????????????????????
# STEP 3: Build deterministic connection string
# ?????????????????????????????????????????????????????????????
Write-Step "Building connection string"

$connectionString = "Host=$pgHost;Port=$pgPort;Database=$pgDb;Username=$pgUser;Password=$pgPwd;SSL Mode=Disable;Trust Server Certificate=true"
Write-Host "Connection: Host=$pgHost;Port=$pgPort;Database=$pgDb;Username=$pgUser;Password=****;SSL Mode=Disable" -ForegroundColor DarkGray

# ?????????????????????????????????????????????????????????????
# STEP 4: Verify TCP connectivity with password (CRITICAL)
# ?????????????????????????????????????????????????????????????
Write-Step "Verifying TCP connection with password authentication"

# Use psql with explicit TCP connection (-h) and password (PGPASSWORD)
$testResult = docker exec -e "PGPASSWORD=$pgPwd" $ContainerName psql -h 127.0.0.1 -p 5432 -U $pgUser -d $pgDb -c "SELECT 1 AS connection_test;" 2>&1

if ($LASTEXITCODE -ne 0) {
    Write-Fail "TCP connection failed with password"
    Write-Host $testResult -ForegroundColor Red
    Write-Host ""
    Write-Host "Troubleshooting:" -ForegroundColor Yellow
    Write-Host "  1. Verify password in docker-compose.yml matches POSTGRES_PASSWORD"
    Write-Host "  2. Run: docker-compose down -v && docker-compose up -d"
    Write-Host "  3. Wait 5 seconds for PostgreSQL to initialize"
    exit 1
}
Write-Ok "TCP connection verified"

# ?????????????????????????????????????????????????????????????
# STEP 5: Export connection string for EF Core
# ?????????????????????????????????????????????????????????????
Write-Step "Exporting MIC_CONNECTION_STRING for EF Core"

$env:MIC_CONNECTION_STRING = $connectionString
[Environment]::SetEnvironmentVariable('MIC_CONNECTION_STRING', $connectionString, 'Process')

Write-Ok "MIC_CONNECTION_STRING exported"
Write-Host "  Value: Host=$pgHost;Port=$pgPort;Database=$pgDb;Username=$pgUser;Password=****;SSL Mode=Disable" -ForegroundColor DarkGray

# ?????????????????????????????????????????????????????????????
# STEP 6: Restore NuGet packages
# ?????????????????????????????????????????????????????????????
Write-Step "Restoring NuGet packages"

dotnet restore $SlnPath --verbosity quiet
if ($LASTEXITCODE -ne 0) {
    Write-Fail "NuGet restore failed"
    exit 1
}
Write-Ok "Packages restored"

# ?????????????????????????????????????????????????????????????
# STEP 7: Apply EF Core migrations
# ?????????????????????????????????????????????????????????????
Write-Step "Applying EF Core migrations"

$efArgs = @(
    'ef', 'database', 'update',
    '--project', 'MIC.Infrastructure.Data',
    '--startup-project', 'MIC.Console',
    '--context', 'MicDbContext'
)

if ($VerboseEf) {
    $efArgs += '--verbose'
}

Write-Host "Running: dotnet $($efArgs -join ' ')" -ForegroundColor DarkGray

& dotnet @efArgs
if ($LASTEXITCODE -ne 0) {
    Write-Fail "EF Core migration failed"
    Write-Host ""
    Write-Host "Debug steps:" -ForegroundColor Yellow
    Write-Host "  1. Check MicDbContextFactory console output above"
    Write-Host "  2. Verify appsettings.json has correct ConnectionStrings:MicDatabase"
    Write-Host "  3. Run: dotnet ef dbcontext info --project MIC.Infrastructure.Data --startup-project MIC.Console"
    exit 1
}
Write-Ok "Migrations applied successfully"

# ?????????????????????????????????????????????????????????????
# STEP 8: Verify tables exist
# ?????????????????????????????????????????????????????????????
Write-Step "Verifying database schema"

$tableCheck = docker exec -e "PGPASSWORD=$pgPwd" $ContainerName psql -h 127.0.0.1 -U $pgUser -d $pgDb -t -c "SELECT tablename FROM pg_tables WHERE schemaname='public' ORDER BY tablename;"

$tables = ($tableCheck -split "`n" | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' })
$expectedTables = @('Alerts', 'Assets', 'Decisions', 'Metrics', '__EFMigrationsHistory')

$missingTables = $expectedTables | Where-Object { $_ -notin $tables }
if ($missingTables.Count -gt 0) {
    Write-Warn "Missing tables: $($missingTables -join ', ')"
} else {
    Write-Ok "All expected tables present: $($tables -join ', ')"
}

# ?????????????????????????????????????????????????????????????
# STEP 9: Build solution (optional)
# ?????????????????????????????????????????????????????????????
if (-not $SkipBuild) {
    Write-Step "Building solution with zero-warning policy"
    
    dotnet build $SlnPath --no-incremental /warnaserror /nologo /clp:Summary
    if ($LASTEXITCODE -ne 0) {
        Write-Fail "Build failed"
        exit 1
    }
    Write-Ok "Build succeeded: 0 errors, 0 warnings"
}

# ?????????????????????????????????????????????????????????????
# DONE
# ?????????????????????????????????????????????????????????????
Write-Host ""
Write-Host "???????????????????????????????????????????????????????????" -ForegroundColor Green
Write-Ok "Setup complete!"
Write-Host "???????????????????????????????????????????????????????????" -ForegroundColor Green
Write-Host ""
Write-Host "Connection string for manual use:" -ForegroundColor Cyan
Write-Host "  `$env:MIC_CONNECTION_STRING = `"$connectionString`"" -ForegroundColor DarkGray
Write-Host ""

